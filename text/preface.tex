\chapter{Why should we focus on Virtual Machine flexibility?}

\emph{``Impermanent are all component things,\\
They arise and cease, that is their nature:\\
They come into being and pass away,\\
Release from them is bliss supreme.''} 

--- Mahaa-Parinibbaana Sutta \cite{1988last}

%\section{Change}
Impermanence is fundamental to living and non-living systems. Computer systems,
composed of hardware and software components, are also subject to permanent
changes. More and more computation power is harnessed through the exponential
growth of the number of transistors available on integrated circuits. An
increasing focus is made on exploiting parallelism and concurrency to tap into
that power. That which once was sequential is now concurrent. Networks of
computers are growing at an exponential rate and federating on the Internet.
That which once was solitary is now collaborative.  Computer-controlled
processes are increasingly pervasive. That which once was manual is now
automated. The level at which we program computers is coming closer to the
level at which human reasoning occurs. That which once was explicit is now
abstracted.  The more we tap into computing power to solve human problems, the
more solutions to other problems come into reach.\footnote{A more pessimistic
view would argue that the more we tap into computer power, the more we
\textit{create} problems that never existed before.} That which once was
impossible is now difficult, then easy. Computer systems are increasingly able
to adapt themselves to their changing environment. That which once was static
is becoming dynamic.

% Coevolution
The evolution of computer systems does not happen by itself but
through coevolution with human programmers, designers and users. The ability of
programmers, designers and users to process information is \textit{not} growing
exponentially. However, their effectiveness in performing tasks \textit{can}
grow exponentially by taping into computing power. The effectiveness of
evolving computer systems can also be increased by taping into computer powers,
which explains the exponential growth of computing power.  

%\section{Methodology}
Being an exponential process, the evolution of computer systems should be
tapped into when change is required. A system as close as possible to the
desired one should serve as the starting point and the system should be evolved
by first improving its ability to evolve in the desired direction.  Then the
system should be modified to achieve desired properties. Our focus should be on
removing hurdles to the evolution of computer systems, at the source of their
occurence.

%\section{Source}
Programming environments, language and tools, serve as a common ground of
understanding between the intents of a programmer and the capabilities of a
computer system. Therefore, the main hurdle to the evolution of a computer
system is the ability of programming environments to accomodate changes. When
it is not possible, programming environments themselves must evolve. The
evolution of programming environments is in turn limited by the
\textit{flexibility} of their \textit{implementation}. 

%\section{Flexibility}
\textit{Flexibility} is the ease of a computer system to accomodate change.
As universal simulators, computer systems can accomodate any change. However,
depending on their current configuration, the evolution of an actual system to
a desired state might be more or less complicated.  Since changes in computer
systems originate in and are performed by humans, the evaluation of
\textit{flexibility} is human-centric. The delay between the conceptualization
of a desired state and its actual realization is a metric to evaluate the
\textit{flexibility} of a computer system. An imperceptible delay would mean
that the system is maximally flexible and inversely.

%Implementation
Programming environment \textit{implementations} are also developed with a
programming environment, using one or multiple programming languages and
various tools. The development environment can be identical or not to the
developed environment.  When identical, the evolution process can feed back on
itself. Improving the developed environment accelerates the development of the
environment itself.  

%Optimization focus
To maximize the rate of evolution of a computer system, we should strive to
make all non-human bound tasks instantaneous. From a human perspective, it
means that all interactions with a computer system should provide
\textit{immediate feedback} at the level of human reasoning for the task at
hand. When applied to the development of the programming environment,
an exponential improvement to the capabilities of the system is achievable, as
long as the limitation to the flexibility are systematically removed in the
order of their importance.

%Virtual Machine
All programming environments ultimately execute on a physical machine using
physical processes to perform computations. A physical implementation of a
computer provides performance and efficiency.  However, modification of this
physical machine is laborious and energy intensive. Seen as universal
simulators, computers can simulate \textit{virtual} machines, given a proper
program describing the expected behavior of the desired machine. By definition,
this virtual machine will provide less performance and efficiency than an
equivalent physical implementation. However, modifications to this virtual
machine is much easier and energy efficient, allowing a faster evolution of its
behavior. 

Therefore, the ultimate place of improvement to the capabilities of computer systems is 
the virtual machine and the main driver of their evolution is its flexibility.
As such, it is a \textit{meta}-property since a faster evolution can lead to
any of the other desired properties faster.

%Performance
\section{Performance}
The performance of a virtual machine can hinder the \textit{flexibility} of a
programming environment by delaying the feedback obtained on modifications.
However, focusing first on evolving the system accelerate the development of a
performant system. The opposite is not true, as focusing first on performance
can introduce barriers to the evolution of the system, potentially breaking the
exponential improvement process.

\section{Reuse and Collaboration}
The development of a computer system can immensely profit from reusing
components existing components and parallelizing the implementation effort.
However, if the components used or developped in parallel introduce limitations
to the evolution the resulting system this can break the exponential
improvement process.  When integrating existing components or developped
components, it is imperative to make sure they are compatible with the
direction of evolution.  Otherwise, this can compromise both the achievement of
the desired state and the speed at which it can be reached.

\section{Social Impact}
The development of computer systems has had far reaching consequences on our
civilization. However, most of the improvements where obtained in technical
sectors and the evolution of computing has been driven by profit-generating
interests. Much of the social sector and non-profit sectors have failed to 
influence the evolution of computer systems.

I postulate that it can be attributed to the technical complexity inherent to
the modification of current systems. For most technical sectors and
profit-generating activities, the profits generated by the organisation are
sufficient to compensate the cost of the technical complexity. However, the
social sector and non-profit generating activities do not have the resources to
address the technical complexity problem.  A truly \textit{flexible} system
would allow those sectors to obtain systems that corresponds to their needs and
would allow them to tap into the potential of computing systems to radically
improve the capabilities of their organization.

% Provide examples?
% Provide bibliographical references for all claims
% Discuss the inspiration for the different ideas




