\chapter{Flexibility}
\label{chap:Flexibility}

\emph{``You must be shapeless, formless, like water. When you pour water in a
cup, it becomes the cup. When you pour water in a bottle, it becomes the
bottle. When you pour water in a teapot, it becomes the teapot. Water can drip
and it can crash. Become like water my friend.''}

--- Bruce Lee \\

Any system exhibits particular compromises between opposing goals. Some
constraints derive from the nature of the problem a particular system is trying
to solve. Different problems might have conflicting constraints. Therefore, a
given system cannot be the ultimate answer to life, the universe and everything
to everybody. It follows that to assert the flexibility of a system, we need to
choose particular use cases and leave others.

The prospect of using the development of the system to drive requirements is
alluring, especially as a requirement analogy to the meta-circularity of the
system. However, we need to keep in mind that it is not sufficient to ensure
that the resulting system is more than a research curiosity. The following
usages are outgrowths of discussions that happened with Bruno Dufour to
determine usage scenarii that were less biaised by my own view of what the
system could be used for.

The single strategy behind every of those scenario is to define a protocol to
implement the element of interest and expose the parts that can vary as a
method, which can be replaced by user code. To emphasize the non-universal
nature of a particular solution, each scenario describes the modification made
to the system presented in the design section (see Section~\ref{chap:Design}).
This is a deliberate choice to illustrate that flexibility is also enabled by
having clear lines of evolution around a unifying principle, in this case,
message-passing.

We first explore simple examples that work without modification to the
protocols of the system, to obtain profiling information in terms of JS operations.
We then discuss circumscribed modifications to the system, to enforce runtime
invariants used to catch common programming mistakes. We conclude with a more
involved example to provide fundational tools for dynamic analysis of JS code.

\section{Obtaining semantic-level profiling information}

Given a good approximation of the performance cost of JS operations, such as
property accesses and object creation, we might be interested in estimating the
performance of an application by computing the run-time frequency of each of
these operations.

The design of the system makes it easy to do by wrapping the method
implementing the semantic operation with a function incrementing a counter.
Instrumenting the property access (\kw{\_\_get\_\_}) might be done in the
following way:

\jsfile{listings/getcount.js}

Notice that the instrumentation can be granular both in time and space, i.e. it
can cover only a part of the execution and a subset of all the objects present
in the system. In the preceding example, it is only performed on the \kw{o}
object. To cover the entire application execution, instrumentation can be performed before
an application is actually started. To cover all objects of a given type, such
as all functions, the corresponding root object method can be instrumented.

The same pattern can be applied to object creation by instrumenting the
\kw{\_\_new\_\_} operation instead.


\section{Verifying runtime invariants}

\subsection{Ensuring that all accesses are made to existing properties}

\subsection{Ensure that a constructor always returns the object it received}


\section{Obtaining a dynamic call graph}

% Overview of the usefulness of dynamic call graph
comprehension, code coverage, 

% Explanation of a dynamic call graph

% Results format

% Instrumentation points at the semantic level of JS

% Required support in the VM

% Implementation

wrap the called function in a closure

% Example programs and output

% Optimizing the instrumentation overhead
