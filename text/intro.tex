\chapter{Introduction}

\funnyquote{Impermanent are all component things,\\
They arise and cease, that is their nature:\\
They come into being and pass away,\\
Release from them is bliss supreme.}
{Mahaa-Parinibbaana Sutta \cite{1988last}}

Computer systems are constantly modified to satisfy the evolving needs of their
users. \textit{Flexible} systems can evolve faster than rigid systems by
placing fewer constraints on possible modifications, thus reducing the delay
between the birth of an idea and its actual realization in a working system.
Aiming for flexibility in the design of computer systems can make other
properties, such as performance, security and reliability, easier to obtain by
facilitating experimentation.

A \textit{virtual machine} (VM) is a program that simulates the behavior of a
computing machine.  The simulated machine might exhibit properties that do not
have physical equivalents. For example, by using a garbage collection
component, it can provide the illusion of infinite allocatable memory. Programs
executing on VMs inherit their properties and constraints, therefore making
them prime research objects to provide properties to an important number of
programs.

Recent research and development on VMs, especially for the JavaScript
language~\cite{js_spec}, has focused on performance, to the expense of
flexibility. Notably, it has hindered our understanding of the run-time
behavior of real-world programs by making instrumentation of existing VMs
laborious. The last published attempt at gathering empirical data for
JavaScript was a one-time effort, where researchers manually instrumented a
production interpreter to obtain execution traces~\cite{behavior_js}. However
this approach prevents the acquisition of longitudinal data because the burden
of maintaining the instrumented interpreter up-to-date is too demanding for any
research team to shoulder.

Fortunately, the very same gains in performance can be used to regain
flexibility, even on a rigid production VM. This dissertation shows that a
sophisticated run-time optimizer can be harnessed to provide flexible run-time
instrumentation of the object model and function-calling protocol at a
performance competitive with a state-of-the-art interpreter, without having to
modify the VM source code. Our approach consists in running a metacircular VM
targeting the source language, based on a message-sending object model, on top
of another fast VM. To demonstrate the approach, we provide a reference VM for
an existing programming language, JavaScript, we show the possibility of
instrumenting the object model operations and function calls and we finally
compare the performance with and without instrumentation to the SpiderMonkey
interpreter and V8 JIT-compiler based VM. 

Although there are existing systems for JavaScript targeting JavaScript as
their runtime, such as Google Caja to enforce security
invariants~\cite{Caja:2012}, Google Traceur to support the next version of
JavaScript on existing VMs~\cite{Traceur:2012} and JSBench to record execution
traces for automatic benchmark generation~\cite{Richards:2011}, we believe our
system is unique in its combination of design choices that makes it simple,
flexible and sufficiently efficient for data gathering of dynamic behavior. As
such, this dissertation contains three original contributions: 
\begin{itemize}
    \item The unification of the reified object model operations and
        function-calling protocol around a single message-sending primitive
        while preserving compatibility with the current version of JavaScript
    \item An efficient implementation of the message-sending primitive inspired
          by inline cache optimizations
    \item An object representation exploiting the underlying VM inline caches
          and dynamic object model to provide efficient virtualized operations
\end{itemize}

In addition to supporting the thesis above, we hope (1) to encourage future
language designs to provide features facilitating an efficient layered approach
to obtain flexibility and (2) the object representation will be used by other
language implementations seeking efficiency while targeting existing JS VMs.

\section{Flexibility}

Defining and evaluating flexibility is no easy task. The usage of the term
above appeal to the intuitive notion of a system easy to tailor to one's
particular usage by modifying, removing or replacing its components. Easy might
mean that there is few lines of code to modify to use a preconfigured option,
that there is few manipulations to perform in a user interface or that unplanned
extensions could be developed in a limited time.

While intuitive, this definition is not sufficiently objective to compare
different systems. It is tied to a subjective interpretation of efforts
required to perform modifications. For the remainder of this dissertation, a
more restricted definition of flexibility will be used. A system will be
considered flexible if it exhibits the four following properties:

\begin{itemize}
    \item \textit{Open}: Its component behaviors can be modified by first-class
        data structures. 
    \item \textit{Extensible}: Its components can be independently modified or
        replaced and they support incremental definitions. 
    \item \textit{Dynamic}: Its components can be modified at run time.
    \item \textit{Efficient}: The resulting system is fast enough for the task
        at hand and allows prompt feedback about the modification.
\end{itemize}

This definition serves both as a design goal for the resulting system and a way
to compare different systems. The notions of \textit{openness},
\textit{extensibility}, \textit{dynamism} and \textit{performance} appear
throughout this dissertation and are used to situate our work against the
literature and other systems.

\section{Virtual machine}

% definition
A \textit{virtual machine} is a program that simulates the behavior of a
computing machine, that may or may not have a physical implementation. It may
be identical to the physical machine on which it is executing, as is the case
with current commercial solutions used to execute different operating systems
as user processes, or it might be completely different, as is the case when
executing a high-level language such as JavaScript.  

% relationship to an operating system
In theory, there is no significant difference between a VM and
an operating system.~\footnote{"An operating system is a collection of
things that don't fit into a language. There shouldn't be one." -- Dan
Ingalls~\cite{Ingalls1981}} They both act as a middle layer between the
underlying machine and programs. They both provide abstractions and
services common to all programs. In fact, VMs for high-level
languages have been made to execute directly on hardware. In practice, the
management of hardware peripherals, memory, processing units and network
interfaces has been associated with operating systems and the support for
higher-level features of programming languages has been associated with
dedicated VMs. This historical distinction has allowed a plethora
of languages to be available for application programmers by allowing language
implementers to focus on supporting the semantics of programming languages
instead of managing the physical machine resources.

% efficiency gap
The major drawback of simulating a computer is the important efficiency
difference between a physical and a virtual implementation, the latter possibly
being orders of magnitude slower than the former. Research on VM
implementation has contributed techniques to minimize this efficiency gap.
Various high-level languages, such as Java, JavaScript, Smalltalk, Scheme or
Prolog, can now execute efficiently on general purpose processors making VMs
practical for application development.

% scope
In this dissertation, our focus will be directed toward VMs constructed to
support programming languages on top of existing VMs. The virtualization of
operating systems, the management of physical resources as well as most of the
low-level details required to execute directly on processors will be ignored.

\section{Metacircularity}

VMs can be described by two languages:
\begin{itemize}
    \item \textit{Source language}. Language used by programs executing on the
        VM.
    \item \textit{Implementation language}. Language that describe the behavior
        of the VM.
\end{itemize}
These languages can be different. For example, current commercial VMs for
JavaScript (source language) are written in C++ (implementation language).  A
special case exists when the two languages are the same, with noteworthy
properties.

When its source language and its implementation language are the same, a VM is
said to be \textit{metacircular}. Advantages of metacircularity are resource
sharing and uniformity of the runtime. For example, a memory manager used to
manage the internal data structures of a VM can be shared with the source
language runtime. Uniformity allows optimizations written for the source
language to also apply to the implementation language. In the context of an
open system, source language code can replace implementation language code to
modify the behavior of the VM. In the literature, \textit{self-hosting} is
also used to describe metacircular systems. I'll restrict this latter term for
describing a system that is \textit{actually} used to produce new versions of
itself.  A metacircular VM needing special extensions or performance that it
cannot provide still depends on an external machine to produce a different
version of itself and is not self-hosting.  Self-hosting is therefore a
stricter definition.  Self-hosting enables a faster evolution of the system by
allowing functionalities developed for the source language to apply to the
implementation language. It frees a system from the limitations of other
available systems that would be needed otherwise. The VM presented in this
dissertation is not self-hosting.

VMs can be implemented as interpreters when the behavior of
programs is directly specified in the implementation language.  However, VMs
can also incorporate a compiler that performs translation of the programs to
the language on which the VM is executing, while the program is executing. We
say such a VM incorporates a Just-In-Time (JIT) Compiler. 

We argued that a VM which incorporates a JIT compiler that
targets its source language is possibly one of the simplest that can be built
that mostly preserve performance characteristic of unmodified source elements.
In fact, it amounts to a \textit{differential} implementation, in which only
the elements of interest in the language are acted upon. Optimizations for the
new functionalities can target existing optimizations of the source language to
efficiently implement them, without having to specify low-level mechanism.
There is even the possibility of faster-than-native performance if some
features can be translated to equivalent features with better performance
characteristics. For these reasons, a metacircular implementation that targets
its source language was chosen.

A metric can be suggested to evaluate the cost of providing functionalities or
properties that are not available in the original source language: the overhead
of executing an original source program on the VM compared to bare execution on
the reference machine. This metric will be used to evaluate the performance
cost of the flexibility gained from the suggested design.

\section{JavaScript}

JS is a dynamic language, imperative but with a strong functional component,
and a prototype-based object system similar to that of Self.

A JS object contains a set of properties (a.k.a. fields in other OO languages),
and a link to a parent object, known as the object's prototype. Properties are
accessed with the notation \kw{obj.prop}, or equivalently \kw{obj["prop"]}.
This allows objects to be treated as dictionaries whose keys are strings, or as
one dimensional arrays (a numeric index is automatically converted to a
string).  When fetching a property that is not contained in the object, the
property is searched in the object's prototype recursively. When storing a
property that is not found in the object, the property is added to the object,
even if it exists in the object's prototype chain. Properties can also be
removed from an object using the \kw{delete} operator. JS treats global
variables, including the top-level functions, as properties of the global
object, which is a normal JS object.

Anonymous functions and nested functions are supported by JS. Function objects
are closures which capture the variables of the enclosing functions. Common
higher-order functions are predefined. For example, the \kw{map}, \kw{forEach}
and \kw{filter} functions allow processing the elements of an array of data
using closures, similarly to other functional languages. All functions accept
any number of actual parameters. The actual parameters are passed in an array,
which is accessible as the \kw{arguments} local variable. The formal parameters
in the function declaration are nothing more than aliases to the corresponding
elements at the beginning of the array. Formal parameters with no corresponding
element in the array are bound to a specific undefined value.

JS also has reflective capabilities (enumerating the properties of an object,
testing the existence of a property, etc.) and dynamic code execution
(\kw{eval} of a string of JS code).  The next version of the standard is
expected to add proper tail calls, rest parameters, block-scoped variables,
modules, and many other features.

Initially, our research initiative chose JS as a research object because it is
widely used to write web applications and there is a performance gap between
benchmarks executing on the fastest implementations and compiled with C/C++
compilers, suggesting there are techniques to be found to close the gap.
During exploration of VM implementation techniques, the dynamic nature of the
language was found to be particularly well-suited to base a flexible design
around it and initiated the work presented here. Notably, the ability to use
the underlying JIT compiler by way of \kw{eval} and the \kw{Function}
constructor function also enables the \textit{differential} implementation of a
JIT compiler by adding preliminary phases to the compilation of the source
programs.

\section{Object Model}

An object model is a set of object kinds, their supported operations and the
time at which those operations can be performed.  Examples of object kinds are
arrays, numbers, associative arrays and classes.  Examples of operations are
object creation, addition, removal or update of properties as well as
modification of the inheritance chain. Examples of time for performing
operations are \textit{run time}, when a program is executing, \textit{compile
time}, when a program is being compiled or \textit{edit time}, when a program's
source code is being modified. An object model structures programs to obtain
properties on the resulting system such as security, extensibility or
performance. Most object models for programming languages provide an
inheritance mechanism to facilitate \textit{extensibility} by allowing an object
to be incrementally defined in terms of an existing object.

Different languages have different object models. \textit{Class-based}
object-oriented languages use \textit{class} objects to describe the properties
and the inheritance chain of \textit{instance} objects. For example, C++ class
objects exist only at compile time. Property values can be updated at run time.
Properties can only be added or removed at edit time and all their accesses are
verified at compile time. Java use run-time objects to represent classes and
allow new classes to be added at run time.  Classes cannot be modified at run
time unless their new definition is reloaded through the debugger API. Ruby
class objects exist at run time and new properties can be added also at run
time. \textit{Prototype-based} object-oriented languages forgo the difference
between class and instance objects. Objects and their inheritance chain is
defined directly on objects. Self and JavaScript object properties can be
added or removed at run time. 

\textit{Message sending} is an operation that invokes a behavior on an object by
executing a program associated to a given message.  A message can exist at run
time and be an object like any other or it can exist only at compile time.
Message sending \textit{decouples} the intention of a program from its
implementation by adding a level of indirection between the invocation and the
execution of a given behavior. This indirection allows the behavior to change
during a program's execution. Therefore, it is a source of \textit{dynamism}.

Some languages call the program associated to a message, a \textit{method
implementation}, the message, a \textit{method name} and the act of sending a
message, \textit{method calling}. This terminology is closely tied to an
implementation strategy where the implementation is a function, the method name
is a compile-time symbol and the method call is a lookup followed by a
synchronous function call in the same address space. We will use the
message-sending terminology because it is more abstract and would easily
accommodate an asynchronous calling mechanism that could happen between different
address spaces, i.e., machines. 

A message-sending object model is an object model that takes message sending as
its primitive operation. It defines every other operation in terms of message
sends. By doing so, every other operation of the object model becomes dynamic,
i.e. it can change at run time. By being based on a single message sending
primitive, the optimization effort can be focused on this primitive and
run-time information can be used to specialize the behavior invoked, providing
an opportunity for \textit{performance}. 

\section{Function-calling Protocol}

The function-calling protocol is a contract between a caller and a callee
function and defines what operation each should perform before and after a
call. For implementers, it usually usually refers to the way arguments are
passed between the caller and the callee and who is responsible for clean-up of
shared data structures such as the stack.

In our system, there is no difference between the passing of arguments of the
host VM and the layered VM. However, to react to function-calling events, there
is a need to have a place to define operations to be executed before and after
calls. We will therefore refer to the function-calling protocol as the
operations that are performed before and after a call. 

The \kw{call} method on functions in JS is already a form of reified calling
protocol. Our design exploits it to change the behavior of \textit{all} function
calls when it is modified, which is not the case in the current standard.

\section{VM Paradigm vs Instrumentation}

It can legitimately be asked what the difference is between a metacircular VM
executing on top of an existing VM and a system that would perform
source-to-source translation at run time. This difference is mostly conceptual
and users of these systems need not know the difference. However, there seems
to be a fundamental difference that governs the range of implementation
techniques available to the implementer: what assumption is made about the
possibility of source code inadvertently interfering with implementation code.
In other words, does the system makes an \textit{open-world} assumption or a
\textit{closed-world} assumption.

In the first case, we will say that the system performs instrumentation of the
source code. In the second case, we will say that the system can be considered
a virtual machine, running on top of another virtual machine. 

Our system makes a closed-world assumption to use the JavaScript global object
for optimizations of implementation mechanisms.

\section{Outline}

Now that the conceptual underpinnings of our work have been established, we can
turn our attention to the actual dissertation: 
\begin{itemize}
    \item Chapter~\ref{chap:PreviousWork} presents previous work on flexible computer systems.
    \item Chapter~\ref{chap:Design} explains the design of the VM with a
        particular emphasis on the message-sending foundation and the object
        representation.
    \item Chapter~\ref{chap:Flexibility} presents use cases in modifying the VM
        that are either difficult or impossible to do with existing JS
        implementations.
    \item Chapter~\ref{chap:Performance} compares my implementation with a
        state-of-the-art implementation to establish the overhead of providing
        the flexibility and show suitability to replace existing instrumented
        interpreters.
    \item Finally, the conclusion in chapter~\ref{chap:Conclusion} explains the
        current limitations of the system and sketches ideas for further work
        using our current results
\end{itemize}
