\chapter{Introduction}

The lack of \textit{flexibility} of current computer systems, i.e. the
important delay between the conceptualization of a desired state and its actual
realization, prevents their timely evolution to suit the needs of their users.
The limitation to their flexibility originate in the implementation of
programming environments, especially at the \textit{virtual machine} level.

I postulate that four properties of virtual machines are responsible for
providing flexibility:
\begin{itemize}
    \item \textit{Openness}. Any part of the system should be modifiable with
    as few constraints as possible on what can be expressed. I favor a
    meta-circular VM implementation, in which modifications can be expressed
    using the high-level source language of the VM. 

    \item \textit{Extensibility}. It should be possible to access and modify
    a part of the system independently of others, including central and low-level
    aspects of the VM. For example, new object representations should be
    supported with no modifications to the core of the VM. New compilers
    should be supported by reusing parts of existing compilers or by
    completely replacing them without modifications to the object model.

    \item \textit{Dynamism}. Modifications should be supported at run time for
    a maximum of flexibility and control. For example, many profiling tasks
    can be greatly simplified by making it possible to redefine some parts of
    the system at run time and revert to the original behavior if needed.

    \item \textit{Performance}. The system should be fast enough to be used as
    a meaningful experimentation tool. Since the execution time of the system
    directly impacts the time required to obtain feedback on an idea,
    performance cannot be underestimated.
\end{itemize}

This thesis presents an implemented virtual machine(VM), Photon, for an existing
mainstream language, JavaScript(JS), that achieves those properties on a set of
tasks that no other JS VM can do. The main contributions are in the working
system and the choice and adaptation of known techniques to build the system.

% TODO: Justify the choice of JavaScript

Before delving into the nuts and bolts of the design and implementation of
Photon, the next section attempts to clarify the \textit{vision} behind the
system. Then, the justification for the choice of a source, a target and an
implementation language are given. The last section of the introduction
formally presents the organisation of the thesis. 

\newpage
\section{Why should we focus on Virtual Machine flexibility?}

\emph{``Impermanent are all component things,\\
They arise and cease, that is their nature:\\
They come into being and pass away,\\
Release from them is bliss supreme.''} 

--- Mahaa-Parinibbaana Sutta \cite{1988last}

%\section{Change}
Impermanence is fundamental to living and non-living systems. Computer systems,
composed of hardware and software components, are also subject to permanent
changes. More and more computation power is harnessed through the exponential
growth of the number of transistors available on integrated circuits. An
increasing focus is made on exploiting parallelism and concurrency to tap into
that power. That which once was sequential is now concurrent. Networks of
computers are growing at an exponential rate and federating on the Internet.
That which once was solitary is now collaborative.  Computer-controlled
processes are increasingly pervasive. That which once was manual is now
automated. The level at which we program computers is coming closer to the
level at which human reasoning occurs. That which once was explicit is now
abstracted.  The more we tap into computing power to solve human problems, the
more solutions to other problems come into reach.\footnote{A more pessimistic
view would argue that the more we tap into computer power, the more we
\textit{create} problems that never existed before.} That which once was
impossible is now difficult, then easy. Computer systems are increasingly able
to adapt themselves to their changing environment. That which once was static
is becoming dynamic.

% Coevolution
The evolution of computer systems does not happen by itself but
through coevolution with human programmers, designers and users. The ability of
programmers, designers and users to process information is \textit{not} growing
exponentially. However, their effectiveness in performing tasks \textit{can}
grow exponentially by taping into computing power. The effectiveness of
evolving computer systems can also be increased by taping into computer powers,
which explains the exponential growth of computing power.  

%\section{Methodology}
Being an exponential process, the evolution of computer systems should be
tapped into when change is required. A system as close as possible to the
desired one should serve as the starting point and the system should be evolved
by first improving its ability to evolve in the desired direction.  Then the
system should be modified to achieve desired properties. Our focus should be on
removing hurdles to the evolution of computer systems, at the source of their
occurence.

%\section{Source}
Programming environments, composed of languages and tools, serve as a common
ground of understanding between the intents of a programmer and the
capabilities of a computer system. Therefore, the main hurdle to the evolution
of a computer system is the ability of programming environments to accomodate
changes. When it is not possible, programming environments themselves must
evolve. The evolution of programming environments is in turn limited by the
\textit{flexibility} of their \textit{implementation}. 

%\section{Flexibility}
\textit{Flexibility} is the ease of a computer system to accomodate change.
As universal simulators, computer systems can accomodate any change. However,
depending on their current configuration, the evolution of an actual system to
a desired state might be more or less complicated.  Since changes in computer
systems originate in and are performed by humans, the evaluation of
\textit{flexibility} is human-centric. The delay between the conceptualization
of a desired state and its actual realization is a metric to evaluate the
\textit{flexibility} of a computer system. An imperceptible delay would mean
that the system is maximally flexible and inversely.

%Implementation
Programming environment \textit{implementations} are also developed with a
programming environment, using one or multiple programming languages and
various tools. The development environment can be identical or not to the
developed environment.  When identical, the evolution process can feed back on
itself. Improving the developed environment accelerates the development of the
environment itself.  

%Optimization focus
To maximize the rate of evolution of a computer system, we should strive to
make all non-human bound tasks instantaneous. From a human perspective, it
means that all interactions with a computer system should provide
\textit{immediate feedback} at the level of human reasoning for the task at
hand. When applied to the development of the programming environment,
an exponential improvement to the capabilities of the system is achievable, as
long as the limitation to the flexibility are systematically removed in the
order of their importance.

%Virtual Machine
All programming environments ultimately execute on a physical machine using
physical processes to perform computations. A physical implementation of a
computer provides performance and efficiency.  However, modification of this
physical machine is laborious and energy intensive. Seen as universal
simulators, computers can simulate \textit{virtual} machines, given a proper
program describing the expected behavior of the desired machine. By definition,
this virtual machine will provide less performance and efficiency than an
equivalent physical implementation. However, modifications to this virtual
machine is much easier and energy efficient, allowing a faster evolution of its
behavior. 

Therefore, the ultimate place of improvement to the capabilities of computer systems is 
the virtual machine and the main driver of their evolution is its flexibility.
As such, it is a \textit{meta}-property since a faster evolution can lead to
any of the other desired properties faster.

%Performance
\subsection{Performance}
The performance of a virtual machine can hinder the \textit{flexibility} of a
programming environment by delaying the feedback obtained on modifications.
However, focusing first on evolving the system accelerate the development of a
performant system. The opposite is not true, as focusing first on performance
can introduce barriers to the evolution of the system, potentially breaking the
exponential improvement process.

\subsection{Reuse and Collaboration}
The development of a computer system can immensely profit from reusing
existing components and parallelizing the implementation effort.
However, if the components used or developped in parallel introduce limitations
to the evolution the resulting system this can break the exponential
improvement process.  When integrating existing components or developped
components, it is imperative to make sure they are compatible with the
direction of evolution.  Otherwise, this can compromise both the achievement of
the desired state and the speed at which it can be reached.

\subsection{Social Impact}
The development of computer systems has had far reaching consequences on our
civilization. However, most of the improvements where obtained in technical
sectors and the evolution of computing has been driven by profit-generating
interests. Much of the social sector and non-profit sectors have failed to 
influence the evolution of computer systems.

I postulate that it can be attributed to the technical complexity inherent to
the modification of current systems. For most technical sectors and
profit-generating activities, the profits generated by the organisation are
sufficient to compensate the cost of the technical complexity. However, the
social sector and non-profit generating activities do not have the resources to
address the technical complexity problem.  A truly \textit{flexible} system
would allow those sectors to obtain systems that corresponds to their needs and
would allow them to tap into the potential of computing systems to radically
improve the capabilities of their organization.

% TODO: Provide examples?
% TODO: Provide bibliographical references for all claims
% TODO: Discuss the inspiration for the different ideas

\section{Source Language}

JS was chosen as a source language for Photon for two main reasons: (i)
because of the dire need to experiment with new implementation strategies for
this particular language, and (ii) to ensure that our results are meaningful in
the context of a mainstream language. 

\section{Target Language}

There is a continuum of functionalities provided by target languages allowing
the choice of a language to match the needs of an application. However, to
facilitate the reflexion on the potential choice of language, I identify three
representative candidates that in my opinion cover the range of languages that
could be targeted, in decreasing order of functionalities provided:
\begin{itemize}
    \item \textit{High-level language with fast implementation}: The main
    advantage of targeting a high-level language is to reduce the complexity of
    the implementation of the VM. The target language runtime and compiler can
    provide much of the support for functionnalities required, such as floating
    point number support, exception mecanism and garbage collection. When
    evolving a programming environment, this can be extremely valuable to
    develop the VM and its tools such as a profiler, a debugger or an inspector.
    However, the high-level language and the limitations of its implementation
    introduce limits to the performance achievable.
    \item \textit{Native language}: The main advantage of targeting a native
    language is to allow maximum flexibility in the choice of implementation
    techniques.  In particular, the ability to produce self-modifying code
    can provide efficient techniques to optimize the dynamic features of
    high-level languages. However, compared to a high-level language a lot of
    functionalities need to be implemented and optimized to exploit the
    flexibility. Also, idiosyncracies inherited from a historical legacy of
    backward compatibility need to be dealt with.
    \item \textit{Hardware description language}: The emergence of runtime
    modification mecanisms on hardware circuits, such as dynamic
    reconfiguration on FPGAs, has the potential to bring higher-performance at
    a lower cost in energy by specializing the hardware to the running program.
    In addition, designing the hardware and software part of a VM at the same
    time has the potential of drastically simplifying the complexity of the
    compiler and the hardware implementation by eleminating constraints
    dictated by retro-compatibility requirements on micro-processors.
    However, the performance of current tools, vendor lock-ins and limited
    availability of protocol specifications for reconfigurability stand in the
    way of effective research.
\end{itemize}

Photon targets a native language, x86 assembly, specifically to provide as much
flexibility as possible on the choice of implementation techniques.
Higher-level languages would have made the implementation easier but would have
introduced limitations on the optimizations that could be implemented.
Hardware description languages could have been interesting but the amount of
supporting work needed to bring up a working system would have put it outside
the scope of a master thesis.

\section{Implementation Language}

The implementation language of a virtual machine is usually chosen either to
maximize performance of the compiler and runtime or to simplify the
implementation. In the general case, the implementation language need not be
related to either the source or target language. However, a VM designed with
the same language as source and host provides numerous advantages such as code
reuse, sharing of the runtime and the elimination of conflictual interactions
between the client and host runtime systems. The most important advantage in
for Photon is providing intercession on the systemâ€™s behavior by exposing the
inner components of the VM. For example, having the compiler phases exposed as
JS objects on the global environment enables their redefinition to change the
behavior of eval. 

However, this raises meta-stability issues because infinite recursion can be
introduced inadvertently. For example, if the basic operations of the
language are exposed as object methods, using a property access operation in
the method that defines the property access operation results in an infinite
recursion. While the system is in its early phases, it is advantageous to open
it for easy experimentation because it allows for a faster evolution, even at
the cost of meta-stability issues. Those can be mitigated by restricting our
coding style until these issues are prevented, for example by enforcing them
using the meta-object protocol \cite{Kiczales:1991}.

\section{Outline}

The progression of this thesis goes from the conceptual underpinnings of the
virtual machine, to a design description independent of the target
language, then to the implementation details required by our particular choice
of target and implementation language and ends with an empirical evaluation of
the resulting system.

This organization was chosen to allow the thesis to serve different purposes.
The first chapters, up to and including the chapter~\ref{chap:Design}, describe
the system independent of the target language, to facilitate an implementation
for a different target language.   Chapters~\ref{chap:Exec}, ~\ref{chap:Compiler},
~\ref{chap:Runtime}, ~\ref{chap:Bootstrap} and~\ref{chap:Optimizations} serve as a reference to implement
a native VM for a dynamic language. They could be useful for language
implementers trying to bring up a VM for a different source language. Finally,
the empirical evaluation in chapters~\ref{chap:Flexibility},
~\ref{chap:Complexity}, ~\ref{chap:Performance} could serve to compare the
flexibility of different VMs.
